
import React from 'react';

const Section: React.FC<{ title: string; children: React.ReactNode }> = ({ title, children }) => (
  <div className="mb-8">
    <h2 className="text-2xl md:text-3xl font-bold text-blue-400 border-b-2 border-gray-700 pb-2 mb-4">{title}</h2>
    <div className="space-y-4 text-gray-300 leading-relaxed">
      {children}
    </div>
  </div>
);

const Code: React.FC<{ children: React.ReactNode }> = ({ children }) => (
    <code className="bg-gray-800 text-blue-300 px-2 py-1 rounded-md font-mono text-sm">{children}</code>
);

export const ExplanationPage: React.FC = () => {
  return (
    <div className="w-full max-w-4xl mx-auto animate-fade-in text-left">
      <h1 className="text-4xl font-extrabold text-center mb-8">How It Works: A Technical Deep Dive</h1>
      
      <Section title="1. Initial Image Analysis">
        <p>
            When you upload an image, the first step is to read its fundamental data. This is done using the HTML5 <Code>&lt;canvas&gt;</Code> element, which provides a powerful API for pixel-level manipulation.
        </p>
        <ul className="list-disc list-inside space-y-2 pl-4">
            <li>The image is drawn onto a hidden canvas.</li>
            <li>We then call <Code>context.getImageData()</Code> to get a raw array of pixel data. This array is a flat list of RGBA (Red, Green, Blue, Alpha) values for every single pixel in the image.</li>
            <li>From this data, we can easily calculate properties like width, height, and total pixel count.</li>
            <li><strong>Dominant Colors:</strong> To find the most common colors without checking millions of unique shades, we use a technique called "quantization". We simplify each color by reducing its bit depth (e.g., from 256 possible values per channel to just 16). This groups similar colors together, allowing us to count them efficiently and find the most frequent ones.</li>
            <li><strong>Color Distribution:</strong> The histogram is generated by iterating through all pixels and counting the intensity of each color channel (R, G, B) from 0 to 255.</li>
        </ul>
      </Section>

      <Section title="2. Reconstruction: Mosaic">
        <p>
            The mosaic effect breaks the image down into a grid of solid color blocks.
        </p>
         <ul className="list-disc list-inside space-y-2 pl-4">
            <li>The image is divided into a grid based on the "Block Size" you select.</li>
            <li>For each block in the grid, the algorithm looks at all the original pixels within that area.</li>
            <li>It calculates the <strong>average color</strong> of those pixels by summing up all the R, G, and B values and dividing by the number of pixels.</li>
            <li>Finally, it draws a solid rectangle on the visible canvas with that calculated average color, filling the entire block.</li>
        </ul>
      </Section>
      
      <Section title="3. Reconstruction: Circles (Pointillism)">
        <p>
            This method is inspired by the art style of Pointillism, creating an image from thousands of distinct dots.
        </p>
         <ul className="list-disc list-inside space-y-2 pl-4">
            <li>The algorithm runs a loop for the specified "Number of Circles".</li>
            <li>In each iteration, it picks a completely random X/Y coordinate within the image dimensions.</li>
            <li>It samples the <strong>exact color</strong> of the single pixel at that random location from the original image.</li>
            <li>It then calculates the "brightness" (or luminance) of that pixel's color. A common formula is <Code>(0.299*R + 0.587*G + 0.114*B) / 255</Code>.</li>
            <li>A circle is drawn on the canvas at that random position. Its color is the one we sampled, and its radius is determined by the brightness—brighter pixels create larger circles.</li>
        </ul>
      </Section>

      <Section title="4. Reconstruction: Palette Quantization">
        <p>
            This is a classic computer graphics technique for reducing the number of colors in an image. It reconstructs the entire image using only the 10 dominant colors found in the initial analysis.
        </p>
         <ul className="list-disc list-inside space-y-2 pl-4">
            <li>The algorithm iterates through every single pixel of the original image, from top to bottom, left to right.</li>
            <li>For each pixel, it compares its original color to the 10 colors in the dominant palette.</li>
            <li>It finds the color in the palette that is the <strong>closest match</strong>. This "closeness" is calculated using the Euclidean distance formula in 3D (RGB) space: <Code>sqrt((R1-R2)² + (G1-G2)² + (B1-B2)²)</Code>.</li>
            <li>The pixel on the visible canvas is then drawn using the closest matching color from the palette, effectively "snapping" every original color to its nearest neighbor in the limited palette.</li>
        </ul>
      </Section>
    </div>
  );
};
